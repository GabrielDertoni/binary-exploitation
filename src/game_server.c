#include "game_server.h"
#include "common.h"
#include "uci.h"
#include "fen.h"
#include "moves.h"

bool game_server_init_from_fen(GameServer* this, const char* fen) {
    this->ai_color = COLOR_BLACK;
    ASSERT(parse_fen(&this->game, fen));
    this->is_startpos = true;
    this->is_done = false;
    this->uci_in = NULL;
    this->uci_out = NULL;
    this->uci_linebuf = NULL;
    this->uci_linebuf_cap = 0;
    return true;
}

void game_server_deinit(GameServer* this) {
    free(this->uci_linebuf);
}

bool server_uci_read(GameServer* server, UciCommand* cmd) {
    return uci_read_command(server->uci_in, &server->uci_linebuf, &server->uci_linebuf_cap, cmd);
}

bool server_uci_read_until_kind(GameServer* server, UciCommandKind kind, UciCommand* out) {
    // fprintf(stderr, "[info]: waiting %s\n", uci_command_kind_to_string[kind]);
    while (1) {
        UciCommand cmd;
        if (!server_uci_read(server, &cmd)) {
            ASSERT(!feof(server->uci_in));
            fprintf(
                stderr,
                "[error]: invalid UCI command, expecting '%s'\n",
                uci_command_kind_to_string[kind]
            );
            continue;
        }
        if (cmd.kind == kind) {
            if (out) *out = cmd;
            return true;
        }
    }
}

bool game_server_setup_uci(GameServer* server) {
    fprintf(server->uci_out, "uci\n");
    fflush(server->uci_out);
    ASSERT(server_uci_read_until_kind(server, UCI_OK, NULL));
    fprintf(server->uci_out, "isready\n");
    fflush(server->uci_out);
    ASSERT(server_uci_read_until_kind(server, UCI_READYOK, NULL));
    return true;
}

bool game_server_update(GameServer* server) {
    Game* game = &server->game;

    Move possible_moves[MAX_MOVES];
    memset(possible_moves, 0, sizeof(possible_moves));
    int count = all_valid_moves(game, possible_moves);
    if (count == 0) {
        server->is_done = true;
        fprintf(stderr, "[info] %s wins\n", opposite(game->turn) == COLOR_WHITE ? "white" : "black");
        return true;
    }

    char fen[MAX_FEN_LENGTH + 1];
    game_fen(game, fen);

    if (server->is_startpos) {
        fprintf(server->uci_out, "position startpos\n");
        fflush(server->uci_out);
        server->is_startpos = false;
    } else {
        fprintf(server->uci_out, "position fen %s\n", fen);
    }
    fprintf(server->uci_out, "go depth 10\n");
    fflush(server->uci_out);

    UciCommand cmd;
    ASSERT(server_uci_read_until_kind(server, UCI_BESTMOVE, &cmd));
    Move move = cmd.bestmove.move;
    server->history[server->game.fullmove_counter % HISTORY_MAX] = make_move(&server->game, move);

    game->turn = opposite(game->turn);
    return true;
}